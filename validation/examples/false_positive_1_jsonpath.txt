# FALSE POSITIVE: json-path/JsonPath
# SHA: b6c60b3deef74a83eaa92c8dca7d0bc097e957cd
# Our Score: 45
# Score 45, but this is a random commit (not known to be buggy)
# GitHub: https://github.com/json-path/JsonPath/commit/b6c60b3deef74a83eaa92c8dca7d0bc097e957cd

Commit message: Prepare next version (#1059)

--- README.md (modified) ---
additions: 143, deletions: 120, changes: 263
@@ -7,25 +7,27 @@ Jayway JsonPath
 [![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.jayway.jsonpath/json-path/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.jayway.jsonpath/json-path)
 [![Javadoc](https://www.javadoc.io/badge/com.jayway.jsonpath/json-path.svg)](http://www.javadoc.io/doc/com.jayway.jsonpath/json-path)
 
-Jayway JsonPath is a Java port of [Stefan Goessner JsonPath implementation](http://goessner.net/articles/JsonPath/). 
+Jayway JsonPath is a Java port of [Stefan Goessner JsonPath implementation](http://goessner.net/articles/JsonPath/).
 
 Getting Started
 ---------------
 
 JsonPath is available at the Central Maven Repository. Maven users add this to your POM.
 
 ```xml
+
 <dependency>
     <groupId>com.jayway.jsonpath</groupId>
     <artifactId>json-path</artifactId>
-    <version>2.9.0</version>
+    <version>2.10.0</version>
 </dependency>
 ```
 
-If you need help ask questions at [Stack Overflow](http://stackoverflow.com/questions/tagged/jsonpath). Tag the question 'jsonpath' and 'java'.
+If you need help ask questions at [Stack Overflow](http://stackoverflow.com/questions/tagged/jsonpath). Tag the
+question 'jsonpath' and 'java'.
 
-JsonPath expressions always refer to a JSON structure in the same way as XPath expression are used in combination 
-with an XML document. The "root member object" in JsonPath is always referred to as `$` regardless if it is an 
+JsonPath expressions always refer to a JSON structure in the same way as XPath expression are used in combination
+with an XML document. The "root member object" in JsonPath is always referred to as `$` regardless if it is an
 object or array.
 
 JsonPath expressions can use the dot–notation
@@ -39,18 +41,17 @@ or the bracket–notation
 Operators
 ---------
 
-| Operator                  | Description                                                        |
-| :------------------------ | :----------------------------------------------------------------- |
-| `$`                       | The root element to query. This starts all path expressions.       |
-| `@`                       | The current node being processed by a filter predicate.            |
-| `*`                       | Wildcard. Available anywhere a name or numeric are required.       |
-| `..`                      | Deep scan. Available anywhere a name is required.                  |
-| `.<name>`                 | Dot-notated child                                                  |
-| `['<name>' (, '<name>')]` | Bracket-notated child or children                                  |
-| `[<number> (, <number>)]` | Array index or indexes                                             |
-| `[start:end]`             | Array slice operator                                               |
-| `[?(<expression>)]`       | Filter expression. Expression must evaluate to a boolean value.    |
-
+| Operator                  | Description                                                     |
+|:--------------------------|:----------------------------------------------------------------|
+| `$`                       | The root element to query. This starts all path expressions.    |
+| `@`                       | The current node being processed by a filter predicate.         |
+| `*`                       | Wildcard. Available anywhere a name or numeric are required.    |
+| `..`                      | Deep scan. Available anywhere a name is required.               |
+| `.<name>`                 | Dot-notated child                                               |
+| `['<name>' (, '<name>')]` | Bracket-notated child or children                               |
+| `[<number> (, <number>)]` | Array index or indexes                                          |
+| `[start:end]`             | Array slice operator                                            |
+| `[?(<expression>)]`       | Filter expression. Expression must evaluate to a boolean value. |
 
 Functions
 ---------
@@ -76,25 +77,26 @@ The function output is dictated by the function itself.
 Filter Operators
 -----------------
 
-Filters are logical expressions used to filter arrays. A typical filter would be `[?(@.age > 18)]` where `@` represents the current item being processed. More complex filters can be created with logical operators `&&` and `||`. String literals must be enclosed by single or double quotes (`[?(@.color == 'blue')]` or `[?(@.color == "blue")]`).   
-
-| Operator                 | Description                                                           |
-| :----------------------- | :-------------------------------------------------------------------- |
-| `==`                     | left is equal to right (note that 1 is not equal to '1')              |
-| `!=`                     | left is not equal to right                                            |
-| `<`                      | left is less than right                                               |
-| `<=`                     | left is less or equal to right                                        |
-| `>`                      | left is greater than right                                            |
-| `>=`                     | left is greater than or equal to right                                |
-| `=~`                     | left matches regular expression  [?(@.name =~ /foo.*?/i)]             |
-| `in`                     | left exists in right [?(@.size in ['S', 'M'])]                        |
-| `nin`                    | left does not exists in right                                         |
-| `subsetof`               | left is a subset of right [?(@.sizes subsetof ['S', 'M', 'L'])]       |
-| `anyof`                  | left has an intersection with right [?(@.sizes anyof ['M', 'L'])]     |
-| `noneof`                 | left has no intersection with right [?(@.sizes noneof ['M', 'L'])]    |
-| `size`                   | size of left (array or string) should match right                     |
-| `empty`                  | left (array or string) should be empty                                |
-
+Filters are logical expressions used to filter arrays. A typical filter would be `[?(@.age > 18)]` where `@` represents
+the current item being processed. More complex filters can be created with logical operators `&&` and `||`. String
+literals must be enclosed by single or double quotes (`[?(@.color == 'blue')]` or `[?(@.color == "blue")]`).
+
+| Operator   | Description                                                        |
+|:-----------|:-------------------------------------------------------------------|
+| `==`       | left is equal to right (note that 1 is not equal to '1')           |
+| `!=`       | left is not equal to right                                         |
+| `<`        | left is less than right                                            |
+| `<=`       | left is less or equal to right                                     |
+| `>`        | left is greater than right                                         |
+| `>=`       | left is greater than or equal to right                             |
+| `=~`       | left matches regular expression  [?(@.name =~ /foo.*?/i)]          |
+| `in`       | left exists in right [?(@.size in ['S', 'M'])]                     |
+| `nin`      | left does not exists in right                                      |
+| `subsetof` | left is a subset of right [?(@.sizes subsetof ['S', 'M', 'L'])]    |
+| `anyof`    | left has an intersection with right [?(@.sizes anyof ['M', 'L'])]  |
+| `noneof`   | left has no intersection with right [?(@.sizes noneof ['M', 'L'])] |
+| `size`     | size of left (array or string) should match right                  |
+| `empty`    | left (array or string) should be empty                             |
 
 Path Examples
 -------------
@@ -141,25 +143,25 @@ Given the json
 }
 ```
 
-| JsonPath                                       | Result |
-|:-------------------------------------------------------------------| :----- |
-| `$.store.book[*].author` | The authors of all books     |
-| `$..author`                           | All authors                         |
-| `$.store.*`                           | All things, both books and bicycles  |
-| `$.store..price`                 | The price of everything         |
-| `$..book[2]`                         | The third book                      |
-| `$..book[-2]`                       | The second to last book            |
-| `$..book[0,1]`                     | The first two books               |
-| `$..book[:2]`                       | All books from index 0 (inclusive) until index 2 (exclusive) |
-| `$..book[1:2]`                     | All books from index 1 (inclusive) until index 2 (exclusive) |
-| `$..book[-2:]`                     | Last two books                   |
-| `$..book[2:]`                     | All books from index 2 (inclusive) to last  |
-| `$..book[?(@.isbn)]`                                                 | All books with an ISBN number         |
-| `$.store.book[?(@.price < 10)]`                                      | All books in store cheaper than 10  |
-| `$..book[?(@.price <= $['expensive'])]`                              | All books in store that are not "expensive"  |
-| `$..book[?(@.author =~ /.*REES/i)]`                                  | All books matching regex (ignore case)  |
-| `$..*`                                                               | Give me every thing   
-| `$..book.length()`                                                   | The number of books                      |
+| JsonPath                                | Result                                                       |
+|:----------------------------------------|:-------------------------------------------------------------|
+| `$.store.book[*].author`                | The authors of all books                                     |
+| `$..author`                             | All authors                                                  |
+| `$.store.*`                             | All things, both books and bicycles                          |
+| `$.store..price`                        | The price of everything                                      |
+| `$..book[2]`                            | The third book                                               |
+| `$..book[-2]`                           | The second to last book                                      |
+| `$..book[0,1]`                          | The first two books                                          |
+| `$..book[:2]`                           | All books from index 0 (inclusive) until index 2 (exclusive) |
+| `$..book[1:2]`                          | All books from index 1 (inclusive) until index 2 (exclusive) |
+| `$..book[-2:]`                          | Last two books                                               |
+| `$..book[2:]`                           | All books from index 2 (inclusive) to last                   |
+| `$..book[?(@.isbn)]`                    | All books with an ISBN number                                |
+| `$.store.book[?(@.price < 10)]`         | All books in store cheaper than 10                           |
+| `$..book[?(@.price <= $['expensive'])]` | All books in store that are not "expensive"                  |
+| `$..book[?(@.author =~ /.*REES/i)]`     | All books matching regex (ignore case)                       |
+| `$..*`                                  | Give me every thing                                          
+| `$..book.length()`                      | The number of books                                          |
 
 Reading a Document
 ------------------
@@ -171,8 +173,8 @@ String json = "...";
 List<String> authors = JsonPath.read(json, "$.store.book[*].author");
 ```
 
-If you only want to read once this is OK. In case you need to read an other path as well this is not the way 
-to go since the document will be parsed every time you call JsonPath.read(...). To avoid the problem you can 
+If you only want to read once this is OK. In case you need to read an other path as well this is not the way
+to go since the document will be parsed every time you call JsonPath.read(...). To avoid the problem you can
 parse the json first.
 
 ```java
@@ -182,6 +184,7 @@ Object document = Configuration.defaultConfiguration().jsonProvider().parse(json
 String author0 = JsonPath.read(document, "$.store.book[0].author");
 String author1 = JsonPath.read(document, "$.store.book[1].author");
 ```
+
 JsonPath also provides a fluent API. This is also the most flexible one.
 
 ```java
@@ -193,14 +196,14 @@ List<String> authorsOfBooksWithISBN = ctx.read("$.store.book[?(@.isbn)].author")
 
 
 List<Map<String, Object>> expensiveBooks = JsonPath
-                            .using(configuration)
-                            .parse(json)
-                            .read("$.store.book[?(@.price > 10)]", List.class);
+        .using(configuration)
+        .parse(json)
+        .read("$.store.book[?(@.price > 10)]", List.class);
 ```
 
 What is Returned When?
 ----------------------
-When using JsonPath in java its important to know what type you expect in your result. JsonPath will automatically 
+When using JsonPath in java its important to know what type you expect in your result. JsonPath will automatically
 try to cast the result to the type expected by the invoker.
 
 ```java
@@ -211,24 +214,27 @@ List<String> list = JsonPath.parse(json).read("$.store.book[0].author");
 String author = JsonPath.parse(json).read("$.store.book[0].author");
 ```
 
-When evaluating a path you need to understand the concept of when a path is `definite`. A path is `indefinite` if it contains:
+When evaluating a path you need to understand the concept of when a path is `definite`. A path is `indefinite` if it
+contains:
 
 * `..` - a deep scan operator
 * `?(<expression>)` - an expression
 * `[<number>, <number> (, <number>)]` - multiple array indexes
 
-`Indefinite` paths always returns a list (as represented by current JsonProvider). 
+`Indefinite` paths always returns a list (as represented by current JsonProvider).
 
-By default a simple object mapper is provided by the MappingProvider SPI. This allows you to specify the return type you want and the MappingProvider will
-try to perform the mapping. In the example below mapping between `Long` and `Date` is demonstrated. 
+By default a simple object mapper is provided by the MappingProvider SPI. This allows you to specify the return type you
+want and the MappingProvider will
+try to perform the mapping. In the example below mapping between `Long` and `Date` is demonstrated.
 
 ```java
 String json = "{\"date_as_long\" : 1411455611975}";
 
 Date date = JsonPath.parse(json).read("$['date_as_long']", Date.class);
 ```
 
-If you configure JsonPath to use `JacksonMappingProvider`, `GsonMappingProvider`, or `JakartaJsonProvider` you can even map your JsonPath output directly into POJO's.
+If you configure JsonPath to use `JacksonMappingProvider`, `GsonMappingProvider`, or `JakartaJsonProvider` you can even
+map your JsonPath output directly into POJO's.
 
 ```java
 Book book = JsonPath.parse(json).read("$.store.book[0]", Book.class);
@@ -237,7 +243,8 @@ Book book = JsonPath.parse(json).read("$.store.book[0]", Book.class);
 To obtain full generics type information, use TypeRef.
 
 ```java
-TypeRef<List<String>> typeRef = new TypeRef<List<String>>() {};
+TypeRef<List<String>> typeRef = new TypeRef<List<String>>() {
+};
 
 List<String> titles = JsonPath.parse(JSON_DOCUMENT).read("$.store.book[*].title", typeRef);
 ```
@@ -251,52 +258,56 @@ There are three different ways to create filter predicates in JsonPath.
 Inline predicates are the ones defined in the path.
 
 ```java
-List<Map<String, Object>> books =  JsonPath.parse(json)
-                                     .read("$.store.book[?(@.price < 10)]");
+List<Map<String, Object>> books = JsonPath.parse(json)
+        .read("$.store.book[?(@.price < 10)]");
 ```
 
-You can use `&&` and `||` to combine multiple predicates `[?(@.price < 10 && @.category == 'fiction')]` , 
+You can use `&&` and `||` to combine multiple predicates `[?(@.price < 10 && @.category == 'fiction')]` ,
 `[?(@.category == 'reference' || @.price > 10)]`.
- 
+
 You can use `!` to negate a predicate `[?(!(@.price < 10 && @.category == 'fiction'))]`.
 
 ### Filter Predicates
- 
+
 Predicates can be built using the Filter API as shown below:
 
 ```java
 import static com.jayway.jsonpath.JsonPath.parse;
 import static com.jayway.jsonpath.Criteria.where;
 import static com.jayway.jsonpath.Filter.filter;
 ...
-...
+        ...
 
 Filter cheapFictionFilter = filter(
-   where("category").is("fiction").and("price").lte(10D)
+        where("category").is("fiction").and("price").lte(10D)
 );
 
-List<Map<String, Object>> books =  
-   parse(json).read("$.store.book[?]", cheapFictionFilter);
+List<Map<String, Object>> books =
+        parse(json).read("$.store.book[?]", cheapFictionFilter);
 
 ```
-Notice the placeholder `?` for the filter in the path. When multiple filters are provided they are applied in order where the number of placeholders must match 
-the number of provided filters. You can specify multiple predicate placeholders in one filter operation `[?, ?]`, both predicates must match. 
+
+Notice the placeholder `?` for the filter in the path. When multiple filters are provided they are applied in order
+where the number of placeholders must match
+the number of provided filters. You can specify multiple predicate placeholders in one filter operation `[?, ?]`, both
+predicates must match.
 
 Filters can also be combined with 'OR' and 'AND'
+
 ```java
 Filter fooOrBar = filter(
-   where("foo").exists(true)).or(where("bar").exists(true)
+        where("foo").exists(true)).or(where("bar").exists(true)
 );
-   
+
 Filter fooAndBar = filter(
-   where("foo").exists(true)).and(where("bar").exists(true)
+        where("foo").exists(true)).and(where("bar").exists(true)
 );
 ```
 
 ### Roll Your Own
- 
+
 Third option is to implement your own predicates
- 
+
 ```java 
 Predicate booksWithISBN = new Predicate() {
     @Override
@@ -305,41 +316,44 @@ Predicate booksWithISBN = new Predicate() {
     }
 };
 
-List<Map<String, Object>> books = 
-   reader.read("$.store.book[?].isbn", List.class, booksWithISBN);
+List<Map<String, Object>> books =
+        reader.read("$.store.book[?].isbn", List.class, booksWithISBN);
 ```
 
 Path vs Value
 -------------
-In the Goessner implementation a JsonPath can return either `Path` or `Value`. `Value` is the default and what all the examples above are returning. If you rather have the path of the elements our query is hitting this can be achieved with an option.
+In the Goessner implementation a JsonPath can return either `Path` or `Value`. `Value` is the default and what all the
+examples above are returning. If you rather have the path of the elements our query is hitting this can be achieved with
+an option.
 
 ```java
 Configuration conf = Configuration.builder()
-   .options(Option.AS_PATH_LIST).build();
+        .options(Option.AS_PATH_LIST).build();
 
 List<String> pathList = using(conf).parse(json).read("$..author");
 
-assertThat(pathList).containsExactly(
+assertThat(pathList).
+
+containsExactly(
     "$['store']['book'][0]['author']",
-    "$['store']['book'][1]['author']",
-    "$['store']['book'][2]['author']",
-    "$['store']['book'][3]['author']");
+            "$['store']['book'][1]['author']",
+            "$['store']['book'][2]['author']",
+            "$['store']['book'][3]['author']");
 ```
 
-Set a value 
+Set a value
 -----------
 The library offers the possibility to set a value.
 
 ```java
 String newJson = JsonPath.parse(json).set("$['store']['book'][0]['author']", "Paul").jsonString();
 ```
 
-
-
 Tweaking Configuration
 ----------------------
 
 ### Options
+
 When creating your Configuration there are a few option flags that can alter the default behaviour.
 
 **DEFAULT_PATH_LEAF_TO_NULL**
@@ -373,11 +387,11 @@ String gender0 = JsonPath.using(conf2).parse(json).read("$[0]['gender']");
 //Works fine (null is returned)
 String gender1 = JsonPath.using(conf2).parse(json).read("$[1]['gender']");
 ```
- 
+
 **ALWAYS_RETURN_LIST**
 <br/>
-This option configures JsonPath to return a list even when the path is `definite`. 
- 
+This option configures JsonPath to return a list even when the path is `definite`.
+
 ```java
 Configuration conf = Configuration.defaultConfiguration();
 
@@ -389,12 +403,13 @@ Configuration conf2 = conf.addOptions(Option.ALWAYS_RETURN_LIST);
 //Works fine
 List<String> genders0 = JsonPath.using(conf2).parse(json).read("$[0]['gender']");
 ``` 
+
 **SUPPRESS_EXCEPTIONS**
 <br/>
 This option makes sure no exceptions are propagated from path evaluation. It follows these simple rules:
 
 * If option `ALWAYS_RETURN_LIST` is present an empty list will be returned
-* If option `ALWAYS_RETURN_LIST` is **NOT** present null returned 
+* If option `ALWAYS_RETURN_LIST` is **NOT** present null returned
 
 **REQUIRE_PROPERTIES**
 </br>
@@ -419,76 +434,84 @@ JsonPath is shipped with five different JsonProviders:
 * [JsonSmartJsonProvider](https://github.com/netplex/json-smart-v2) (default)
 * [JacksonJsonProvider](https://github.com/FasterXML/jackson)
 * [JacksonJsonNodeJsonProvider](https://github.com/FasterXML/jackson)
-* [GsonJsonProvider](https://code.google.com/p/google-gson/) 
+* [GsonJsonProvider](https://code.google.com/p/google-gson/)
 * [JsonOrgJsonProvider](https://github.com/stleary/JSON-java)
 * [JakartaJsonProvider](https://javaee.github.io/jsonp/)
 
-Changing the configuration defaults as demonstrated should only be done when your application is being initialized. Changes during runtime is strongly discouraged, especially in multi threaded applications.
-  
+Changing the configuration defaults as demonstrated should only be done when your application is being initialized.
+Changes during runtime is strongly discouraged, especially in multi threaded applications.
+
 ```java
 Configuration.setDefaults(new Configuration.Defaults() {
 
     private final JsonProvider jsonProvider = new JacksonJsonProvider();
     private final MappingProvider mappingProvider = new JacksonMappingProvider();
-      
+
     @Override
-    public JsonProvider jsonProvider() {
+    public JsonProvider jsonProvider () {
         return jsonProvider;
     }
 
     @Override
-    public MappingProvider mappingProvider() {
+    public MappingProvider mappingProvider () {
         return mappingProvider;
     }
-    
+
     @Override
-    public Set<Option> options() {
+    public Set<Option> options () {
         return EnumSet.noneOf(Option.class);
     }
 });
 ```
 
-Note that the JacksonJsonProvider requires `com.fasterxml.jackson.core:jackson-databind:2.4.5` and the GsonJsonProvider requires `com.google.code.gson:gson:2.3.1` on your classpath. 
+Note that the JacksonJsonProvider requires `com.fasterxml.jackson.core:jackson-databind:2.4.5` and the GsonJsonProvider
+requires `com.google.code.gson:gson:2.3.1` on your classpath.
 
-Both of Jakarta EE 9 [JSON-P (JSR-342)](https://javaee.github.io/jsonp/) and [JSON-B (JSR-367)](http://json-b.net/) providers expect at least Java 8 and require compatible JSON API implementations (such as [Eclipse Glassfish](https://projects.eclipse.org/projects/ee4j.jsonp) and [Eclipse Yasson](https://projects.eclipse.org/projects/ee4j.yasson)) on application runtime classpath; such implementations may also be provided by Java EE application container. Please also note that Apache Johnzon is not classpath-compatible with Jakarta EE 9 specification yet, and if JSON-B mapping provider is chosen then JSON-P provider must be configured and used, too.
+Both of Jakarta EE 9 [JSON-P (JSR-342)](https://javaee.github.io/jsonp/) and [JSON-B (JSR-367)](http://json-b.net/)
+providers expect at least Java 8 and require compatible JSON API implementations (such
+as [Eclipse Glassfish](https://projects.eclipse.org/projects/ee4j.jsonp)
+and [Eclipse Yasson](https://projects.eclipse.org/projects/ee4j.yasson)) on application runtime classpath; such
+implementations may also be provided by Java EE application container. Please also note that Apache Johnzon is not
+classpath-compatible with Jakarta EE 9 specification yet, and if JSON-B mapping provider is chosen then JSON-P provider
+must be configured and used, too.
 
-One peculiarity of Jakarta EE 9 specifications for JSON processing and databinding (mapping) is immutability of Json arrays and objects as soon as they are fully parsed or written to. To respect the API specification, but allow JsonPath to modify Json documents through add, set/put, replace, and delete operations, `JakartaJsonProvider` has to be initiliazed with optional `true` argument:
+One peculiarity of Jakarta EE 9 specifications for JSON processing and databinding (mapping) is immutability of Json
+arrays and objects as soon as they are fully parsed or written to. To respect the API specification, but allow JsonPath
+to modify Json documents through add, set/put, replace, and delete operations, `JakartaJsonProvider` has to be
+initiliazed with optional `true` argument:
 
 * `JsonProvider jsonProvider = new JakartaJsonProvider(true)` (enable mutable Json arrays and objects)
 * `JsonProvider jsonProvider = new JakartaJsonProvider()` (default, strict JSON-P API compliance)
 
-All lookup and read operations with JsonPath are supported regardless of initilization mode. Default mode also needs less memory and is more performant.
-  
+All lookup and read operations with JsonPath are supported regardless of initilization mode. Default mode also needs
+less memory and is more performant.
 
 ### Cache SPI
 
-In JsonPath 2.1.0 a new Cache SPI was introduced. This allows API consumers to configure path caching in a way that suits their needs. The cache must be configured before it is accesses for the first time or a JsonPathException is thrown. JsonPath ships with two cache implementations
+In JsonPath 2.1.0 a new Cache SPI was introduced. This allows API consumers to configure path caching in a way that
+suits their needs. The cache must be configured before it is accesses for the first time or a JsonPathException is
+thrown. JsonPath ships with two cache implementations
 
 * `com.jayway.jsonpath.spi.cache.LRUCache` (default, thread safe)
 * `com.jayway.jsonpath.spi.cache.NOOPCache` (no cache)
 
-If you want to implement your own cache the API is simple. 
+If you want to implement your own cache the API is simple.
 
 ```java
 CacheProvider.setCache(new Cache() {
     //Not thread safe simple cache
     private Map<String, JsonPath> map = new HashMap<String, JsonPath>();
 
     @Override
-    public JsonPath get(String key) {
+    public JsonPath get (String key){
         return map.get(key);
     }
 
     @Override
-    public void put(String key, JsonPath jsonPath) {
+    public void put (String key, JsonPath jsonPath){
         map.put(key, jsonPath);
     }
 });
 ```
 
-
-
-
-
-
 [![Analytics](https://ga-beacon.appspot.com/UA-54945131-1/jsonpath/index)](https://github.com/igrigorik/ga-beacon)

--- build.gradle (modified) ---
additions: 2, deletions: 2, changes: 4
@@ -42,15 +42,15 @@ ext {
 
             ]
     ]
-    snapshotVersion = false
+    snapshotVersion = true
 }
 
 allprojects {
     ext.displayName = null
     ext.buildTimestamp = new Date().format('yyyy-MM-dd HH:mm:ss')
 
     group = 'com.jayway.jsonpath'
-    version = '2.10.0' + (snapshotVersion ? "-SNAPSHOT" : "")
+    version = '2.11.0' + (snapshotVersion ? "-SNAPSHOT" : "")
 
 }
 

